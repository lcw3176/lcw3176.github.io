---
layout: post
title:  "Heap"
date:   2022-11-22 15:23:37 +0900
categories:
---
# Heap

## 개요, 특징
### 자료구조
* 완전 이진 트리, 우선 순위 큐
* 최댓값, 최솟값 탐색에 사용
* 종류
    * 최대 힙:부모 노드 >= 자식 노드
    * 최소 힙: 자식 노드 >= 부모 노드
* 인덱스
    * 첫 인덱스는 0이 아닌 1로 잡는것이 수월함
    * 부모 인덱스 = (자식 인덱스) / 2
    * 왼쪽 자식 = (부모 인덱스) * 2
    * 오른쪽 자식 = (부모 인덱스) * 2 + 1
### 메모리 구조
* 동적 할당 영역
* 동적 생성된 클래스 데이터 저장
    - 스택: 클래스 주소(0x0001) 저장
    - 힙: 0x0001의 데이터 저장 
    - 참조 끊기면 GC에 의해 수거

## 장점
### 자료구조
* 삽입, 삭제
    - O(log N)
    - 입,출력 자체는 O(1)
    - heapify를 거쳐야 하기 때문에 O(log N) 
### 메모리 구조
- 스택에 비해 자유로운 용량
- 상황에 맞게 유동적 조절 가능

## 단점
### 자료구조
* 불균형 데이터 상황
    - 트리가 균형잡혀 있을 때만 O(log N)
    - 만약 1,2,3,4.... 같은 데이터라면?
    - O(n), 리스트같은 자료구조와 차이가 없음
### 메모리 구조
- 할당, 해제에 의한 속도 저하
- 힙 경합으로 인한 속도 저하
- 해제 주체에 따른 단점
    - 프로그래머가 하는 경우
        - 깜빡하는 순간 메모리 누수
    - 가비지 컬렉터
        - 동작하는 시점에 프로그램 버벅임
        - 동작 시점이 불명확

```python
class Heap:
    def __init__(self):
        self.item = [None]

    
    def push(self, data):
        self.item.append(data)
        i = len(self.item) - 1

        while i > 1:
            if self.item[i] > self.item[i // 2]:
                self.item[i], self.item[i // 2] = self.item[i // 2], self.item[i]
                i = i // 2
            else:
                break


    def pop(self):
        if len(self.item) < 1:
            raise IndexError("Empty heap")

        value = self.item[1]
        del self.item[1]
        self.heapify(1)
        return value
    

    def heapify(self, parent):
        left_child = 2 * parent
        right_child = 2 * parent + 1
        next_index = parent

        if left_child < len(self.item) and self.item[parent] < self.item[left_child]:
            next_index = left_child
        
        if right_child < len(self.item) and self.item[parent] < self.item[right_child]:
            next_index =right_child
        
        if next_index != parent:
            self.item[parent], self.item[next_index] = self.item[next_index], self.item[parent] 
            self.heapify(next_index)



    def __str__(self):
        return str(self.item[1::1])

```