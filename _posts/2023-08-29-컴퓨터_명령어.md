---
date: 2023-08-29
layout: post
title: 컴퓨터 명령어, 명령어 형식, 종류
categories: [Hardware]
image: >-
    https://github.com/lcw3176/lcw3176.github.io/assets/59993347/7ac8daaf-b85b-4c07-979c-555bf1c0b054
---

# 컴퓨터 명령어

## OPERAND와 OP-CODE 

컴퓨터 명령어의 기본적인 구성요소는 오퍼레이션 코드(Op-code)와 
오퍼랜드(Operand)로 구분된다.

Op-Code는 CPU에서 실행될 연산을 지정하는 부분이며,
오퍼랜드는 연산을 실행하는 데 필요한 데이터 혹은 주소 값을 가지고 있다. 

## 명령어의 분류 

컴퓨터 명령어 형식은 크게 2가지로 다음과 같이 분류된다.

1. 오퍼랜드의 기억장소에 따른 명령어 형식
2. 오퍼랜드의 수에 따른 명령어 형식

### 기억 장소에 따른 명령어 형식

#### 누산기를 이용하는 명령어 형식

누산기(Accumulator)를 가진 컴퓨터 구조에서 사용되는 형식이다.

누산기란 누산기를 가진 컴퓨터 구조에서 중앙처리장치에 있는 유일한 데이터 레지스터로서
명령어가 수행될 때 오퍼랜드를 기억시키는 레지스터이다.

누산기를 이용한 명령어는 다음과 같이 동작한다.

```
1. ADD X ; AC <- AC + M[X]

2. LOAD X ; AC <- M[X]

3. STORE X ; M[X] <- AC
```
1번과 같이 덧셈을 하라는 명령어가 있다.

한 가지 특이한 점이 있다면 덧셈의 대상이 한 가지밖에 없다는 것인데,
보통 이런 식의 표기는 CPU 안의 특정 장소에 데이터가 존재한다는 전제를 암묵적으로
깔고 가는 것이고, 그 데이터가 있는 특정 장소가 바로 누산기이다.

그러므로 이 명령어의 뜻은 '누산기에 있는 내용과 기억장치 X번지에 있는 내용을 더해서 누산기로 전송하라' 라는 뜻이다.

2번 또한 누산기를 이용한다는 전제하에 '기억장치 X번지에 있는 내용을 누산기로 적재해라'
라는 뜻과 같고,

3번도 '누산기의 내용을 기억장치 X번지에 저장하라' 라고 해석할 수 있다.

#### 다중 레지스터를 이용하는 명령어 형식

다중 레지스터를 가진 컴퓨터 구조는 중앙처리장치 내에 
여러 개의 레지스터를 가지고 있는 컴퓨터이다.

```
1. ADD R1, R2, R3 ; R3 <- R1 + R2

2. ADD R1, R2 ; R2 <- R1 + R2

3. MOVE R1, R2 ; R2 <- R1

4. LOAD X, R1 ; R1 <- M[X]

5. STORE R1, X ; M[X] <- R1
```

1번 명령어는 '레지스터 R1의 내용과 레지스터 R2의 내용을 더해서 레지스터 R3로 전송하라' 와 같은 의미이며, 여기서 R1, R2 레지스터는 데이터가 출발한 곳이기 때문에 출발 레지스터라고도 부르며, 최종 결과가 옮겨진 R3 레지스터는 도착 레지스터 라고 표현하기도 한다.

2번 명령어는 '레지스터 R1의 내용과 레지스터 R2의 내용을 더해서 레지스터 R2로 전송하라'라는 의미이다.

3번은 '레지스터 R1의 내용을 레지스터 R2로 전송하라', 4번은 '기억장치 X번지의 내용을 레지스터 R1에 적재하라', 5번은 '레지스터 R1의 내용을 기억장치 X번지에 저장하라'와 같은 뜻이 된다. 
 
#### 스택 구조를 이용하는 명령어 형식

스택 구조 컴퓨터는 연산에 필요한 오퍼랜드들을 기억장치 스택에 기억시켜야 하고, 연산의 결과도 스택에 기억시키는 구조이다.

후입선출인 스택의 구조 특성상 연산과 관련된 데이터들이 차곡차곡 쌓이게 되고,
스택의 맨 위(Top Of Stack)를 기억하는 스택 포인터(SP)가 필요하다. 스택 포인터 또한 일종의 레지스터이며 자료를 꺼낼 때 마다 주소값을 아래칸으로 이동시켜야 한다.

어차피 스택의 위쪽에서 지속적으로 데이터를 꺼내오기 때문에 오퍼랜드를 별도로 표시하지 않으며, OP-Code만 기입해준다.

```
1. ADD ; TOS <- TOS + TOS-1

2. PUSH X ; TOS <- M[X]

3. POP X ; M[X] <- TOS
```

이러한 스택 자료구조의 특성 때문에 
1번 명령어는 '기억장치 스택의 맨 위의 내용과 그 아래의 내용을 더해서 스택의 맨 위로 전송하라'와 같은 뜻이된다.

2번 명령어는 '기억장치 주소 X의 내용을 기억장치 스택의 맨 위로 전송하라'와 같은 뜻이 되며,
3번은 '스택 데이터를 기억장치 X로 옮겨라' 라는 뜻이다.

### 오퍼랜드 수에 따른 명령어 형식

오퍼랜드의 갯수에 따라 명령어를 분류하는 방식이며, 
오퍼랜드의 갯수가 3개면 3주소 명령어, 2개면 2주소 명령어, 1개면 1주소 명령어, 
0개면 0주소 명령어라고 부른다.

#### 3주소 명령어

명령어 오퍼랜드의 개수가 세 개인 명령어 형식이다.
만약 산술식 X = (A + B) * C 를 3주소 명령어를 이용해 프로그래밍 하면 
다음과 같이 기술할 수 있다.

```
X = (A + B) * C 

ADD A, B, R1 ; R1 <- M(A) + M(B)
MUL R1, C, X ; M(X) <- R1 * M(C)
```

3주소 명령어는 산술식을 프로그램화 하는데 있어서 프로그램의 길이가 짧아진다는 장점이 있으나, 2진 코드화 했을 때 세 개의 오퍼랜드를 나타내기 위한 비트 수가 다른 주소 명령어 형식보다 많이 필요하다는 단점이 있다.

#### 2주소 명령어

똑같은 산술식을 2주소 명령어로 나타낸다면 다음과 같다.

```
X = (A + B) * C 

LOAD A, R1 ; R1 <- M(A)
ADD B, R1 ; R1 <- R1 + M(B)
MUL C, R1 ; R1 <- R1 * M(C)
STORE R1, X ; M(X) <- R1
```

3주소 명령어에 비해 명령어의 길이는 짧아졌으나 같은 내용을 수행하기 위해 계산해야 하는 명령어의 수는 증가된 것을 확인할 수 있다.

#### 1주소 명령어

오퍼랜드의 개수가 하나인 명령어 형식으로, 
기억장치로부터 오퍼랜드를 가져오거나 연산결과를 저장하기 위한 임시적인 장소로 누산기 레지스터를 사용한다.

모든 연산은 누산기 레지스터와 기억장치에 저장된 오퍼랜드를 대상으로 수행하며, 프로그램을 수행하기 위해 사용되는 명령어의 수는 더욱 더 증가된다.

#### 0주소 명령어

명령어의 길이가 매우 짧아져 기억공간을 적게 차지하지만, 특수한 경우를 제외하고는 
많은 양의 정보가 스택과 기억장치 사이를 이동하게 되어 비효율적이다.

## 주소 지정 방식

프로그램 수행 시 오퍼랜드를 지정하는 방식으로, 명령어의 주소 필드를 변경하거나 해석하는 규칙을 지정한다. 주소지정방식을 사용하면 명령어의 수를 줄일 수 있는 효과적인 프로그래밍이 가능하다.

유효 주소라는 개념을 사용하는데, 이는 주소지정방식의 각 규칙에 의해 정해지는 오퍼랜드의 실제 주소를 의미한다.

|연산코드|주소지정방식|주소 혹은 오퍼랜드|

다음과 같이 구성되며, 연산코드 필드는 수행할 연산의 종류를 지정하고
주소지정방식 필드는 연산에 필요한 오퍼랜드의 주소를 알아내는 데 사용한다.
주소 혹은 오퍼랜드 필드는 기억장치주소 혹은 레지스터를 나타낸다.

주소 지정 방식의 종류로는 

1. 의미 주소 지정 방식
2. 즉치 주소 지정 방식
3. 직접 주소 지정 방식
4. 간접 주소 지정 방식
5. 레지스터 주소 지정 방식
6. 레지스터 간접 주소 지정 방식
7. 상대 주소 지정 방식
8. 인덱스된 주소 지정 방식

이 존재한다.

## 참고
- 방송통신대학교, 컴퓨터 구조 3강(김형근), 컴퓨터명령어(II)