---
layout: post
title:  "CPU"
date:   2022-11-28 15:26:37 +0900
categories:
---
# CPU
## ALU(Arithmetic and Logical Unit)
### 구성요소
- 산술 연산 장치
    - 덧셈, 곱셈 등의 산술 연산을 수행
- 논리 연산 장치
    - AND, OR 등의 논리 연산을 수행
- 시프트 레지스터
    - 비트들을 시프트 시키는 기능을 가짐
- 보수기
    - 데이터를 2의 보수화함(음수화)
- 상태 레지스터
    - 연산 결과의 상태를 나타내는 플래그 저장


## 제어 유닛(Control Unit)
### 수행 기능
- 명령어 코드 해독
- 명령어 실행에 필요한 제어 신호 발생
### 명령어 세트 설계
1. 명령어 종류, 비트 패턴 정의
2. 명령어 실행에 필요한 하드웨어 설계
3. 각 명령어를 위한 실행 사이클 루틴을 마이크로프로그래밍

## INSTRUCTION
### 명령어 사이클
1. 인출(instruction fetch) -> 인출 사이클
2. 실행(instruction execution) -> 실행 사이클

### 인출 사이클
1. 프로그램 카운터(PC)가 가리키는 주소의 명령어 인출
2. MAR을 통해 주소 전송
3. 기억 장치 명령어 읽음
4. MBR에 데이터 적재, PC 주소 증가 -> 다음 명령어 주소 가리킴
5. MBR 명령어 코드 IR로 이동

### 실행 사이클
#### 데이터 이동
```
## LOAD addr

t0: MAR <- IR(addr)
t1: MBR <- M[MAR]
t2: AC <- MBR

## 기억장치 데이터 -> AC 이동
## 오퍼랜드(addr): 연산 코드의 주소
```
0. IR에 적재된 오퍼랜드를 MAR를 통해 기억장치로 전송
1. 메모리의 데이터 인출하여 MBR에 저장
2. 데이터 AC 레지스터에 적재

#### 데이터 저장
```
## STA addr

t0: MAR <- IR(addr)
t1: MBR <- AC
t2: M[MAR] <- MBR

```
0. 데이터 저장할 메모리 주소 MAR 전송
1. 저장할 데이터 MBR 이동
2. 메모리 데이터 저장

#### 데이터 처리
```
## ADD addr

t0: MAR <- IR(addr)
t1: MBR <- M[MAR]
t2: AC <- AC + MBR
```
0. 오퍼랜드 기억장치로 전송
1. 기억장소 데이터 인출 후 적재
2. 인출한 데이터 + AC 레지스터 내용 -> AC 레지스터에 저장

#### 프로그램 제어
- 분기(branch) 명령어
```
## JUMP addr

t0: PC <- IR(addr)
```
0. 분기 목적지 주소 적재, 명령어 실행 순서 변경  

### 인터럽트
#### 인터럽트 사이클
0. 인터럽트 가능 여부 파악
1. 현재 PC 주소 스택에 저장 (ISR 종료 후 복귀할 주소)
2. ISR 시작 주소 PC 적재

#### 마이크로 연산 과정
```
t0: MBR <- PC
t1: MAR <- SP, PC <- ISR의 시작 주소
t2: M[MAR] <- MBR, SP <- SP - 1

## SP(stack pointer) 
## => 스택의 최상위 주소, 일반적으로 주기억장치의 마지막 주소
```
0. PC 내용 MBR 전송
1. SP 내용 MAR을 통해 주소 버스로 나감, PC에 ISR 시작 주소 적재
2. MBR에 저장된 PC 내용 스택에 저장, SP 내용 감소

### 간접 사이클
```
## 명령어의 주소가 데이터가 저장된 기억 장소의 주소를 가리키는 경우
## 실행 사이클 이전에 데이터 실제 주소를 읽어오는 과정이 선행되어야 함
## 아마 c언어 포인터 비슷한듯

t0: MAR <- IR(addr)
t1: MBR <- M[MAR]
t2: IR(addr) <- MBR
```
0. 명령어 주소 받음
1. 주소 내용 다시 인출
2. IR에 저장

### 명령어 파이프라이닝
#### 2단계 파이프라이닝
```
c0: 인출
c1: 선인출된 명령어 실행, 다음 명령어 인출
c2: 실행, 인출....
```
- 장점
    - 인출, 실행 단계로 분리
    - 첫 클럭 후 부터는 명령어 인출, 실행 한 클럭에 완료
    - 처리할 명령어 많아질수록 속도 향상 이론적으론 거의 2배
- 한계
    - 명령어의 인출과 실행에 같은 길이의 시간이 소요되는 전제가 깔림
    - 실행 단계가 보통 더 길게 처리됨, 끝날 때까지 인출 대기
    - 이런 이유들 때문에 속도 향상 2배 못미침

#### 4단계 파이프라이닝
```
## 명령어 인출(IF)
## 명령어 해독(ID)
## 오퍼랜드 인출(OF)
## 실행(EX)

c0: IF
c1: ID, IF
c2: OF, ID, IF
c3: EX, OF, ID, IF
c4: EX, OF, ID, IF.....
```
- 장점
    - 명령어 증가할수록 속도 향상 이론적으로 4배 근접
- 한계
    - 모든 명령어가 4개 or k개의 단계를 모두 필요로 하지는 않음
    - 가장 오래 걸리는 단계를 기준으로 클럭이 정해짐, 다른 명령어들 대기시간 생김
    - IF, OF 단계는 기억장치 접근 필요, 둘 중 하나는 지연
    - 분기 명령어, 인터럽트 등이 실행되면 미리 인출되어 처리되던 명령어들 무효화

##### 파이프라이닝 개선
- 슈퍼 파이프라이닝
    - 파이프라인 단계를 더욱 세분화함, 10단계 이상
- IF, OF의 접근을 명령어 캐시와 데이터 캐시로 분리
- 분기 예측
    - 분기 발생을 예측, 그에 맞는 경로의 명령어 인출
    - 확률적 방법, 분기 역사 표 참고
- 분기 목적지 선인출
    - 분기 발생시 다음 명령어 + 분기 목적지 명령어 인출
    - 지연 시간 줄임
- 루프 버퍼
    - 최근 인출된 명령어 모임소
    - 분기 목적지 명령어 버퍼에 존재시, 버퍼에서 명령어 인출
- 지연 분기
    - 명령어 재배치, 분기 실행 원래보다 미룸
    - 분기에 따른 성능 저하 최소화

## Register
### Software
#### 내부 레지스터
- 프로그램 카운터(Program Counter)
    - 다음에 인출될 명령어 주소를 가짐
    - 인출 후에는 자동적으로 증가
    - 분기 명령 실행 시 목적지 주소로 갱신
- 누산기(Accumulator)
    - 데이터 일시 저장
    - 비트 수 == cpu 한번에 연산 처리량 == word 길이
- 명령어 레지스터(Instruction Register)
    - 가장 최근 인출된 명렁어 저장
- 기억장치 주소 레지스터(Memory Address Register)
    - 프로그램 카운터에 저장된 명령어 일시 저장
    - 시스템 주소 버스로 출력됨
    - 프로그램 카운터를 주소 버스로 전달하는 역할
-  기억장치 버퍼 레지스터(Memory Buffer Register)
    - 기억장치 데이터가 일시 저장
    - 데이터 버스 선과 연결됨
    - CPU로 데이터 입,출력 전달 역할