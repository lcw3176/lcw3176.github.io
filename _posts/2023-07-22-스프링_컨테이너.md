---
date: 2023-07-22
layout: post
title: 스프링 컨테이너
subtitle: 빈의 생성 과정
description: 빈의 생성 과정
image: >-
    https://github.com/lcw3176/lcw3176.github.io/assets/59993347/5a6bc088-13f4-4275-bb01-ec3bddd232f1
category: backend
tag:
- Framework
- Spring
---

## 스프링의 자바 빈은 어떻게 생성될까?

스프링 컨테이너에 등록되는 빈은 어떤 방식으로 생성되는지 궁금해졌다.

그래서 한 번 인텔리제이로 코드를 따라가봤다. 아마 틀렸을 수도 있다...

## 싱글톤이란?

일단 스프링은 기본적으로 싱글톤으로 빈을 생성한다.
그렇다면 싱글톤 패턴이 무엇인지 잠시 알아보자.


> 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 
이와 같은 디자인 유형을 싱글턴 패턴이라고 한다. 주로 공통된 객체를 여러개 생성해서 사용하는 DBCP(DataBase Connection Pool)와 같은 상황에서 많이 사용된다.

라고 위키백과에 정의되어 있다.

핵심은 하나의 객체만 생성되어야 한다는 것이고, 이를 통해 효율적인 자원 사용을 하겠다는 것이 목표다.

## 구현 방법

```java
public class Singleton {
    private static Singleton instance;

    private Singleton(){

    }

    public static Singleton getInstance(){
        if(instance == null){
            instance = new Singleton();
        }

        return instance;
    }
} 
```

가장 단순한 구현법이다.

하지만 여러 스레드가 동시에 접근했을 때 하나의 인스턴스가 생성된다는 명제를 보장할 수 없다는 문제점이 있다.

getInstance() 메소드에 synchronized 와 같은 키워드를 걸어서 해당 상황을 방지할 수는 있으나, 이는 성능 저하라는
또다른 문제가 생기게 된다.


```java
public class Singleton {
    private final static Singleton instance = new Singleton();

    private Singleton(){

    }

    public static Singleton getInstance(){
        return instance;
    }
} 
```

이를 개선하기 위해 static 멤버의 특성을 이용, JVM이 최초 로딩 때 클래스를 로딩함과 동시에 인스턴스를 만들어 버리는 방법도 존재한다.

하지만 이는 효율적인 자원 활용과는 거리가 존재한다. 해당 인스턴스를 사용 안 할 경우에도 생성되기 때문이다.

```java
public class Singleton {
    private static class singleInstanceHolder {
        private static final Singleton INSTACE = new Singleton();
    }

    public static Singleton getInstance(){
        return singleInstanceHolder.INSTANCE;
    }
} 


public enum SingletonEnum {
    INSTANCE;

    public void helloWorld(){

    }
}
```

가장 유명하면서 많이 사용되는 두 가지 방법이다. 

별도의 홀더 클래스를 만들어 인스턴스를 호출할 때 static 변수에 객체를 할당하거나, 
enum 클래스로 만들어 버리는 방법이다.

## 빈은 어떻게 생성되는가?

```java
@SpringBootApplication
public class HelloApplication {

    public static void main(String[] args) {
        SpringApplication.run(Hello.class, args) // -> 해당 함수 역추적;
    }

}
```

이제 스프링이 어떻게 컨테이너 빈을 등록시키는지 본격적으로 알아보자.

필자는 메인 클래스의 SpringApplication.run() 메소드를 중점적으로 추적해가며 코드를 가져왔다.



```java
private <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {
	ClassLoader classLoader = getClassLoader();
	// Use names and ensure unique to protect against duplicates
	Set<String> names = new LinkedHashSet<>(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
	List<T> instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
	AnnotationAwareOrderComparator.sort(instances);
	return instances;
}

private <T> List<T> createSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes,
			ClassLoader classLoader, Object[] args, Set<String> names) {
	List<T> instances = new ArrayList<>(names.size());
	for (String name : names) {
		try {
			Class<?> instanceClass = ClassUtils.forName(name, classLoader);
			Assert.isAssignable(type, instanceClass);
			Constructor<?> constructor = instanceClass.getDeclaredConstructor(parameterTypes);
			T instance = (T) BeanUtils.instantiateClass(constructor, args);
			instances.add(instance);
		}
		catch (Throwable ex) {
			throw new IllegalArgumentException("Cannot instantiate " + type + " : " + name, ex);
		}
	}
	return instances;
}

    // .....


public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {
	Assert.notNull(ctor, "Constructor must not be null");
	try {
		ReflectionUtils.makeAccessible(ctor);
		if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {
			return KotlinDelegate.instantiateClass(ctor, args);
		}
		else {
			Class<?>[] parameterTypes = ctor.getParameterTypes();
			Assert.isTrue(args.length <= parameterTypes.length, "Can't specify more arguments than constructor parameters");
			Object[] argsWithDefaultValues = new Object[args.length];
			for (int i = 0 ; i < args.length; i++) {
				if (args[i] == null) {
					Class<?> parameterType = parameterTypes[i];
					argsWithDefaultValues[i] = (parameterType.isPrimitive() ? DEFAULT_TYPE_VALUES.get(parameterType) : null);
				}
				else {
					argsWithDefaultValues[i] = args[i];
				}
			}
			return ctor.newInstance(argsWithDefaultValues);
		}
    }
        // ......
}


    // ....

public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException,
               IllegalArgumentException, InvocationTargetException
    {
    if (!override) {
        Class<?> caller = Reflection.getCallerClass();
        checkAccess(caller, clazz, clazz, modifiers);
    }
    if ((clazz.getModifiers() & Modifier.ENUM) != 0)
        throw new IllegalArgumentException("Cannot reflectively create enum objects");
    ConstructorAccessor ca = constructorAccessor;   // read volatile
    if (ca == null) {
        ca = acquireConstructorAccessor();
    }
       
    @SuppressWarnings("unchecked")
    T inst = (T) ca.newInstance(initargs);
    return inst;
}
```

약속 좀 다녀왔다가 마저 작성


## 참고
- 위키백과, 싱글턴 패턴, https://ko.wikipedia.org/wiki/%EC%8B%B1%EA%B8%80%ED%84%B4_%ED%8C%A8%ED%84%B4
- 큰돌의 터전, 제대로 이해하는 싱글톤패턴 - 실습#1, https://www.youtube.com/watch?v=3rfbnQYOCFA
- 큰돌의 터전, 제대로 이해하는 싱글톤패턴 - 실습#2, https://www.youtube.com/watch?v=4Sk9dzXgKwo
 