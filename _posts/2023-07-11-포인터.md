---
date: 2023-07-11
layout: post
title: 포인터는 왜 필요할까
categories: [Language]
image: >-
    https://github.com/lcw3176/lcw3176.github.io/assets/59993347/fad5b938-664a-4d9a-8375-233f60c0edd4
---

## 뒤바뀐 인과관계

포인터에 대해 검색하던 도중 내가 궁금한 요소가 해결되지 않았다.

'포인터 탄생 배경' 등에 대해 검색을 해 보면 대부분의 검색 결과가
포인터가 '필요한 이유'가 아닌 포인터가 등장해서 얻은 이점과 같은 '결과'에 대한 서술이 많았다.

원래 전공이 하드웨어에 가까운 학과라 포인터의 당위성에 대해 부분적으로 어렴풋이 알고 있었는데, 
이번 기회에 확실히 더 찾아봐서 정리를 해 보려고 한다.

## 포인터란?

![image](http://www.tcpschool.com/lectures/img_c_memory_structure.png)

> C언어에서 포인터란 메모리의 주소값을 저장하는 변수이며, 포인터 변수라고도 부릅니다.
char형 변수가 문자를 저장하고, int형 변수가 정수를 저장하는 것처럼 포인터는 주소값을 저장합니다. -TCP 스쿨

포인터는 주소값을 저장하는 변수이다. 예를 들어서,
```
char *arr = malloc(sizeof(char) * 10);
```
이렇게 포인터 변수를 선언한다면 '변수'는 스택에 저장되고, '변수를 가리키는 주소(데이터)'는 힙에 저장된다.

포인터 사용 시 메모리 주소를 참조하기 때문에 배열과 같은 연속된 데이터에 접근과 조작이 용이하고,
동적 할당된 메모리 영역(힙 영역)에 접근과 조작이 용이하다고 한다.

그런데 갑자기 궁금해진다. 계속 나오는 단어가 **주소** 인데, 왜 주소를 참조해야 할까?
결국 이 의문을 풀어야 포인터를 왜 사용하는 지 알 것 같은데, 소프트웨어 레벨에서는 명쾌한 답을 찾기 힘들다.

한 단계 더 아래로 내려가보자.

## DRAM의 구조
![dram](https://user-images.githubusercontent.com/59993347/135577191-12e6d8c4-0f69-4b6f-add7-6a0f24214df1.png)

우리가 흔히 컴퓨터에 장착하는 메모리, 주기억장치는 DRAM이다.

DRAM은 캐패시터를 저장소자로 사용하고 전하 누수, 지속적 refresh 필요, 가격 저렴, 속도 느림 이런 특징들이 있다고 하지만
우리의 관심사는 아니다. 

아주 심플하게 이것만 기억해보자.

- 전하 없음 -> 0, 전하 있음 -> 1 
- 1비트의 데이터 저장 가능 -> 기억장소(cell)

## 데이터 접근 과정
![memorycell](https://github.com/lcw3176/lcw3176.github.io/assets/59993347/a568f677-bed2-46b9-9af7-07cdccc59f8f)

해당 그림 우측의 네모네모한 아이들이 위에서 말한 데이터 저장 장소, 셀이다.
현재 64개의 셀이 존재하고, 6개의 주소선이 이어져 있는 것을 볼 수 있다.

그림을 보고 감이 왔을 수 있는데, 주소를 활용하는 이유는 훨씬 효율적이기 때문이다.
설명을 이어 하자면, 행과 열을 선택할 수 있게 하는 주소선이 3개씩 나뉘어져 디코더 등의 IC 칩으로 입력된다.
Row Address Buffer로 들어간 3개의 신호는 셀의 행, 즉 8개의 가로선 중 하나를 특정할 수 있게 한다. (2^3 = 8)

그러면 특정된 셀의 행의 데이터는 Sense Amp에 올라가고, Column Address Buffer의 신호를 이용해 8개의 셀 중 1개를 
선정할 수 있게 된다.

## 주소를 사용하지 않는다면?
![디코더](https://user-images.githubusercontent.com/59993347/135578878-4f80c49e-2090-4fed-a549-f0ff9ac1490d.jpg)

위에 언급한 과정을 더 간략화 한 그림이다.

주소 개념을 사용한 경우 위와 같이 6개의 신호선만으로 다양한 셀에 접근할 수 있었다.
만약 주소를 사용하지 않고 저 셀마다 데이터 선을 1대 1로 연결할 경우, 64개의 선이 연결되어야 한다. 
점점 차이가 얼마나 벌어지는지 비교를 해보자.

- 주소선 6 == 단일 연결 64 (2^3 * 2^3)

아직은 할만하다. 만약 1,024 개의 셀을 사용한다고 하면?

- 주소선 10 == 단일 연결 1,024 (2^5 * 2^5)

슬슬 버겁다. 만약 40억 개의 셀을 사용한다고 하면?

- 주소선 32 == 단일 연결 4,294,967,296 (2^16 * 2^16)

말도 안되게 차이나는 것을 볼수 있다. 결국 효율을 위해서 주소 개념을 사용하는 것이고,
포인터는 그 개념을 적극적으로 활용할 수 있는 도구였다. 

## 참고
- 딴딴's 반도체사관학교, 한 눈에 보는 DRAM 동작원리,  https://sshmyb.tistory.com/174
- TCP school, 메모리의 구조, http://www.tcpschool.com/c/c_memory_structure
- Computer Science, Dynamic Random Access Memory (DRAM). Part 2: Read and Write Cycles, https://www.youtube.com/watch?v=x3jGqOrXXc8
- st-lab, 메모리 구조 [Memory Structure], https://st-lab.tistory.com/198