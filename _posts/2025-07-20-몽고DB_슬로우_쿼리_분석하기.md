---
date: 2025-07-20
layout: post
title: 몽고DB 슬로우 쿼리 분석하기
categories: [Backend]
image: https://github.com/user-attachments/assets/f52dff09-0073-46a1-81be-2ae1ccf60782
---

## 영향력

고객사에서 특정 기능 조회가 너무 느리다고 연락이 왔다. 
바로 스케일업 얘기가 나왔는데, 그것보다는 더 나은 방안이 분명히 있을 것 같았다.
좋은 경험이 될 것 같아서 내가 주말에 조사해보고 월요일날 공유하기로 했다.

요즘 일하다가 종종, 내가 하는 업무가 비즈니스적으로 얼마나 영향력이 있을까 고민해본다. 
어차피 우리가 개발하는 이유도 다 회사 사업에 기여해서 돈 벌려고 하는거 아니겠나.
가끔 혼자서 발악하는 기분이 든다.
'쟤는 그냥 일이 좋나 보네' 라는 말로 내가 고민했던 시간들이 너무나도 쉽게 다뤄지는 것 같다.  
그럴땐 그냥 내가 운이 좋은 놈이라 생각한다. 적성에 맞는 직업을 가진다는 건 축복이다.
그래도 같은 관심사를 공유하는 사람들과 함께하고 싶다는 소망은 늘 있다.
결국 이 문단의 끝도 비겁하게, 사실 다 알면서 '모르겠다' 라는 말로 회피하려나 보다.
내 다음 스텝은 뭘 해야 좋을까. 모르겠다.

혼자 주저리주저리 해봤다. 각설하고 쿼리 얘기나 해보자.  

## 현황 파악

채팅 목록이랑 세부 채팅을 조회할 때 퍼포먼스가 느려진다고 해서 데이터가 어느정도인지, 스펙은 어느정도인지 살펴봤다.
정리해보면 다음과 같다.

- API 호출: 3 ~ 6s
- DB 스펙: 4 vCore, 16GB 램, 256GB 저장소
- 채팅 목록: 100만건
- 세부 채팅 내역: 300만건

인덱스는 id랑 생성 시각, 업데이트 시각에만 걸려있는데 이 조건들로 쿼리를 안해서... 사실상 없다.
쿼리중 일부는 문자 검색을 위해 정규표현식을 이용한다. 쉽게 말하면 MySQL의 Like %'텍스트'% 라고 보면 된다.
어디를 고쳐야 좋을까 생각해보다가,
검색 조건 같은건 그쪽의 요구사항이었을 가능성이 높다보니, 갑자기 필터 조건이 바뀐다면 문제가 생길수도 있을 것 같아서 인덱스를 효율적으로 걸어보기로 했다

한 가지 다행인건 쿼리의 순서가 중요한 RDB에 비해, 몽고의 aggregation Pipeline에는 여러 매칭 조건이 있다면 인덱스를 효율적으로 활용한다는 것이다.
예를 들어보자면,

```
db.collection.aggregate([
  {
    $match: {
      userId: ObjectId("xxx"),                    // ✅ 인덱스 존재
      content: { $regex: "검색어", $options: "i" } // ❌ 인덱스 없음
    }
  }
])
```

이런 식으로 여러개의 매칭 조건이 섞여있다면 인덱스를 활용해 범위를 좁히고 작업을 진행한다.

1. IXSCAN (userId 인덱스 사용)
2. FETCH (userId로 걸러진 도큐먼트 조회)
3. FILTER (content regex 적용)

요렇게 말이다. 

## 개발 환경 세팅

개발을 위해 우리쪽 환경도 유사하게 부하를 줘봤다. 
사양은 낮아지고 데이터는 더 많아졌기 때문에 더 오버드라이브 했다는 표현이 맞을 것 같다.
기존의 1 : 3 비율이던 채팅 목록과 채팅내역 도 1 : 4로 조절해봤다. 구성한 환경은 다음과 같다. 

- API 호출: 3 ~ 6s
- DB 스펙:  2 vCore, 8GB 램, 32GB 저장소
- 채팅 목록: 100만건
- 세부 채팅 내역: 400만건

api 호출 시간도 비슷하게 맞춰졌고, 인덱스를 이리저리 걸어봤다.



